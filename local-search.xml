<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>go语言编码规范要求</title>
    <link href="/2022/12/17/go%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83/"/>
    <url>/2022/12/17/go%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h1 id="Go编码规范要求："><a href="#Go编码规范要求：" class="headerlink" title="Go编码规范要求："></a>Go编码规范要求：</h1><p>1，使用断言时，需要增加断言检测，否则如果是非目标类型，会报panic错误；</p><p>2， 获取一个数组的子数组时，不要使用数组切片的方式，而是应该建立一个新数组，符合的往里面append，最后返回这个新数组；</p><p>3， 缩进错误处理逻辑，而不是缩进常规代码，因为这样可以改进代码的可读性，读者可以快速地浏览逻辑主干。</p><p>这是一个不好的代码风格，正常逻辑代码被缩进在 else 分支里面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">//error handling</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//normal code</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个不错的代码风格，没有增加正常逻辑代码的缩进：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// error handling</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-comment">// or continue, etc.</span><br>&#125;<br><span class="hljs-comment">// normal code</span><br></code></pre></td></tr></table></figure><p>4, 如果需要用函数的返回值来初始化某个变量，应该把这个函数调用单独写在一行，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">x, err := f()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// error handling</span><br>    <span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// use x</span><br></code></pre></td></tr></table></figure><p>变量命名：</p><p>[建议] 非导出的常量应该是首字母小写的「大小写混合」模式，如 maxLength，而不是 MaxLength 或者 MAX_LENGTH。</p><p> [建议] 包的名字应该是一个全小写的单词。不应有下划线或者大小写混合。同时不用复数命名。例如 net&#x2F;url，而不是 net&#x2F;urls。</p><h1 id="Go编码规范指南"><a href="#Go编码规范指南" class="headerlink" title="Go编码规范指南"></a>Go编码规范指南</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>看过很多方面的编码规范，可能每一家公司都有不同的规范，这份编码规范是写给我自己的，同时希望我们公司内部同事也能遵循这个规范来写Go代码。</p><p>如果你的代码没有办法找到下面的规范，那么就遵循标准库的规范，多阅读标准库的源码，标准库的代码可以说是我们写代码参考的标杆。</p><h2 id="格式化规范"><a href="#格式化规范" class="headerlink" title="格式化规范"></a>格式化规范</h2><p>go默认已经有了gofmt工具，但是我们强烈建议使用goimport工具，这个在gofmt的基础上增加了自动删除和引入包.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">go get golang.org<span class="hljs-regexp">/x/</span>tools<span class="hljs-regexp">/cmd/g</span>oimports<br></code></pre></td></tr></table></figure><p>不同的编辑器有不同的配置, sublime的配置教程：<a href="http://michaelwhatcott.com/gosublime-goimports/">Michael Whatcott - GoSublime + GoImports &#x3D; :)</a></p><p>LiteIDE默认已经支持了goimports，如果你的不支持请点击属性配置-&gt;golangfmt-&gt;勾选goimports</p><p>保存之前自动fmt你的代码。</p><h2 id="行长约定"><a href="#行长约定" class="headerlink" title="行长约定"></a>行长约定</h2><p>一行最长不超过80个字符，超过的请使用换行展示，尽量保持格式优雅。</p><h2 id="go-vet"><a href="#go-vet" class="headerlink" title="go vet"></a>go vet</h2><p>vet工具可以帮我们静态分析我们的源码存在的各种问题，例如多余的代码，提前return的逻辑，struct的tag是否符合标准等。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">go get golang.org<span class="hljs-regexp">/x/</span>tools<span class="hljs-regexp">/cmd/</span>vet<br></code></pre></td></tr></table></figure><p>使用如下：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">go vet .<br></code></pre></td></tr></table></figure><h2 id="package名字"><a href="#package名字" class="headerlink" title="package名字"></a>package名字</h2><p>保持package的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，尽量和标准库不要冲突。</p><h2 id="import-规范"><a href="#import-规范" class="headerlink" title="import 规范"></a>import 规范</h2><p>import在多行的情况下，goimports会自动帮你格式化，但是我们这里还是规范一下import的一些规范，如果你在一个文件里面引入了一个package，还是建议采用如下格式：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>如果你的包引入了三种类型的包，标准库包，程序内部包，第三方包，建议采用如下方式进行组织你的包：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br><br>    <span class="hljs-string">&quot;myproject/models&quot;</span><br>    <span class="hljs-string">&quot;myproject/controller&quot;</span><br>    <span class="hljs-string">&quot;myproject/utils&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/astaxie/beego&quot;</span><br>    <span class="hljs-string">&quot;github.com/go-sql-driver/mysql&quot;</span><br>)   <br></code></pre></td></tr></table></figure><p>有顺序的引入包，不同的类型采用空格分离，第一种实标准库，第二是项目包，第三是第三方包。</p><p>在项目中不要使用相对路径引入包：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 这是不好的导入<br>import “../net”<br><br><span class="hljs-regexp">//</span> 这是正确的做法<br>import “github.com<span class="hljs-regexp">/repo/</span>proj<span class="hljs-regexp">/src/</span>net”<br></code></pre></td></tr></table></figure><h2 id="变量申明"><a href="#变量申明" class="headerlink" title="变量申明"></a>变量申明</h2><p>变量名采用驼峰标准，不要使用<code>_</code>来命名变量名，多个变量申明放在一起</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">var</span> (<br>    Found bool<br>    <span class="hljs-keyword">count</span> <span class="hljs-built_in">int</span><br>)<br></code></pre></td></tr></table></figure><p>在函数外部申明必须使用var,不要采用<code>:=</code>，容易踩到变量的作用域的问题。</p><h2 id="自定义类型的string循环问题"><a href="#自定义类型的string循环问题" class="headerlink" title="自定义类型的string循环问题"></a>自定义类型的string循环问题</h2><p>如果自定义的类型定义了String方法，那么在打印的时候会产生隐藏的一些bug</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m MyInt)</span></span> String() <span class="hljs-type">string</span> &#123;     <span class="hljs-keyword">return</span> fmt.Sprint(m)   <span class="hljs-comment">//<span class="hljs-doctag">BUG:</span>死循环</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(m MyInt)</span></span> String() <span class="hljs-type">string</span> &#123;     <span class="hljs-keyword">return</span> fmt.Sprint(<span class="hljs-type">int</span>(m))   <span class="hljs-comment">//这是安全的,因为我们内部进行了类型转换</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="避免返回命名的参数"><a href="#避免返回命名的参数" class="headerlink" title="避免返回命名的参数"></a>避免返回命名的参数</h2><p>如果你的函数很短小，少于10行代码，那么可以使用，不然请直接使用类型，因为如果使用命名变量很<br>容易引起隐藏的bug</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">func <span class="hljs-constructor">Foo(<span class="hljs-params">a</span> <span class="hljs-params">int</span>, <span class="hljs-params">b</span> <span class="hljs-params">int</span>)</span> (<span class="hljs-built_in">string</span>, ok)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>当然如果是有多个相同类型的参数返回，那么命名参数可能更清晰：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *Foo)</span></span> Location() (<span class="hljs-type">float64</span>, <span class="hljs-type">float64</span>, <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p>下面的代码就更清晰了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Location returns f&#x27;s latitude and longitude.</span><br><span class="hljs-comment">// Negative values mean south and west, respectively.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *Foo)</span></span> Location() (lat, long <span class="hljs-type">float64</span>, err <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>错误处理的原则就是不能丢弃任何有返回err的调用，不要采用<code>_</code>丢弃，必须全部处理。接收到错误，要么返回err，要么实在不行就panic，或者使用log记录下来</p><h3 id="error-信息"><a href="#error-信息" class="headerlink" title="error 信息"></a>error 信息</h3><p>error的信息不要采用大写字母，尽量保持你的错误简短，但是要足够表达你的错误的意思。</p><h2 id="长句子打印或者调用，使用参数进行格式化分行"><a href="#长句子打印或者调用，使用参数进行格式化分行" class="headerlink" title="长句子打印或者调用，使用参数进行格式化分行"></a>长句子打印或者调用，使用参数进行格式化分行</h2><p>我们在调用<code>fmt.Sprint</code>或者<code>log.Sprint</code>之类的函数时，有时候会遇到很长的句子，我们需要在参数调用处进行多行分割：</p><p>下面是错误的方式：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">log.<span class="hljs-constructor">Printf(“A <span class="hljs-params">long</span> <span class="hljs-params">format</span> <span class="hljs-params">string</span>: %<span class="hljs-params">s</span> %<span class="hljs-params">d</span> %<span class="hljs-params">d</span> %<span class="hljs-params">s</span>”, <span class="hljs-params">myStringParameter</span>, <span class="hljs-params">len</span>(<span class="hljs-params">a</span>)</span>,<br>    expected.Size, defrobnicate(“Anotherlongstringparameter”,<br>        expected.Growth.<span class="hljs-constructor">Nanoseconds()</span> /<span class="hljs-number">1e6</span>))<br></code></pre></td></tr></table></figure><p>应该是如下的方式：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">log</span>.Printf(     “A long <span class="hljs-keyword">format</span> <span class="hljs-keyword">string</span>: %s %d %d %s”,     myStringParameter,<br>    len(a),<br>    expected.Size,<br>    defrobnicate(<br>        “Anotherlongstringparameter”,<br>        expected.Growth.Nanoseconds()/<span class="hljs-number">1e6</span>,     ),<br>）   <br></code></pre></td></tr></table></figure><h2 id="注意闭包的调用"><a href="#注意闭包的调用" class="headerlink" title="注意闭包的调用"></a>注意闭包的调用</h2><p>在循环中调用函数或者goroutine方法，一定要采用显示的变量调用，不要再闭包函数里面调用循环的参数</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">fori:=<span class="hljs-number">0</span>;<span class="hljs-selector-tag">i</span>&lt;limit;<span class="hljs-selector-tag">i</span>++&#123;<br>    go <span class="hljs-built_in">func</span>()&#123; <span class="hljs-built_in">DoSomething</span>(i) &#125;() <span class="hljs-comment">//错误的做法</span><br>    go <span class="hljs-built_in">func</span>(i int)&#123; <span class="hljs-built_in">DoSomething</span>(i) &#125;(i)<span class="hljs-comment">//正确的做法</span><br>￼&#125;<br></code></pre></td></tr></table></figure><p><a href="http://golang.org/doc/articles/race_detector.html#Race_on_loop_counter">http://golang.org/doc/articles/race_detector.html#Race_on_loop_counter</a></p><h2 id="在逻辑处理中禁用panic"><a href="#在逻辑处理中禁用panic" class="headerlink" title="在逻辑处理中禁用panic"></a>在逻辑处理中禁用panic</h2><p>在main包中只有当实在不可运行的情况采用panic，例如文件无法打开，数据库无法连接导致程序无法<br>正常运行，但是对于其他的package对外的接口不能有panic，只能在包内采用。</p><p>强烈建议在main包中使用log.Fatal来记录错误，这样就可以由log来结束程序。</p><h2 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h2><p>注释可以帮我们很好的完成文档的工作，写得好的注释可以方便我们以后的维护。详细的如何写注释可以<br>参考：<a href="http://golang.org/doc/effective_go.html#commentary">http://golang.org/doc/effective_go.html#commentary</a></p><h3 id="bug注释"><a href="#bug注释" class="headerlink" title="bug注释"></a>bug注释</h3><p>针对代码中出现的bug，可以采用如下教程使用特殊的注释，在godocs可以做到注释高亮：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// BUG(astaxie):This divides by zero. </span><br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">i</span> <span class="hljs-attribute">float</span> = <span class="hljs-number">1</span>/<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><a href="http://blog.golang.org/2011/03/godoc%C2%ADdocumenting%C2%ADgo%C2%ADcode.html">http://blog.golang.org/2011/03/godoc­documenting­go­code.html</a></p><h2 id="struct规范"><a href="#struct规范" class="headerlink" title="struct规范"></a>struct规范</h2><h3 id="struct申明和初始化格式采用多行："><a href="#struct申明和初始化格式采用多行：" class="headerlink" title="struct申明和初始化格式采用多行："></a>struct申明和初始化格式采用多行：</h3><p>定义如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">type</span> <span class="hljs-keyword">User</span> <span class="hljs-title">struct</span>&#123;<br>    Username  <span class="hljs-keyword">string</span><br>    Email     <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>初始化如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">u := User&#123;<br>    Username: <span class="hljs-string">&quot;astaxie&quot;</span>,<br>    Email:    <span class="hljs-string">&quot;astaxie@gmail.com&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="recieved是值类型还是指针类型"><a href="#recieved是值类型还是指针类型" class="headerlink" title="recieved是值类型还是指针类型"></a>recieved是值类型还是指针类型</h3><p>到底是采用值类型还是指针类型主要参考如下原则：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">func</span>(w Win) <span class="hljs-built_in">Tally</span>(playerPlayer)int    <span class="hljs-comment">//w不会有任何改变 </span><br><span class="hljs-built_in">func</span>(w *Win) <span class="hljs-built_in">Tally</span>(playerPlayer)int    <span class="hljs-comment">//w会改变数据</span><br></code></pre></td></tr></table></figure><p>更多的请参考：<a href="https://code.google.com/p/go-wiki/wiki/CodeReviewComments#Receiver_Type">https://code.google.com/p/go-wiki/wiki/CodeReviewComments#Receiver_Type</a></p><h3 id="带mutex的struct必须是指针receivers"><a href="#带mutex的struct必须是指针receivers" class="headerlink" title="带mutex的struct必须是指针receivers"></a>带mutex的struct必须是指针receivers</h3><p>如果你定义的struct中带有mutex,那么你的receivers必须是指针</p><h2 id="序言-1"><a href="#序言-1" class="headerlink" title="序言"></a>序言</h2><p>看过很多方面的编码规范，可能每一家公司都有不同的规范，这份编码规范是写给我自己的，同时希望我们公司内部同事也能遵循这个规范来写Go代码。</p><p>如果你的代码没有办法找到下面的规范，那么就遵循标准库的规范，多阅读标准库的源码，标准库的代码可以说是我们写代码参考的标杆。</p><h2 id="格式化规范-1"><a href="#格式化规范-1" class="headerlink" title="格式化规范"></a>格式化规范</h2><p>go默认已经有了gofmt工具，但是我们强烈建议使用goimport工具，这个在gofmt的基础上增加了自动删除和引入包.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">go get golang.org<span class="hljs-regexp">/x/</span>tools<span class="hljs-regexp">/cmd/g</span>oimports<br></code></pre></td></tr></table></figure><p>不同的编辑器有不同的配置, sublime的配置教程：<a href="http://michaelwhatcott.com/gosublime-goimports/">http://michaelwhatcott.com/gosublime-goimports/</a></p><p>LiteIDE默认已经支持了goimports，如果你的不支持请点击属性配置-&gt;golangfmt-&gt;勾选goimports</p><p>保存之前自动fmt你的代码。</p><h2 id="行长约定-1"><a href="#行长约定-1" class="headerlink" title="行长约定"></a>行长约定</h2><p>一行最长不超过80个字符，超过的请使用换行展示，尽量保持格式优雅。</p><h2 id="go-vet-1"><a href="#go-vet-1" class="headerlink" title="go vet"></a>go vet</h2><p>vet工具可以帮我们静态分析我们的源码存在的各种问题，例如多余的代码，提前return的逻辑，struct的tag是否符合标准等。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">go get golang.org<span class="hljs-regexp">/x/</span>tools<span class="hljs-regexp">/cmd/</span>vet<br></code></pre></td></tr></table></figure><p>使用如下：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">go vet .<br></code></pre></td></tr></table></figure><h2 id="package名字-1"><a href="#package名字-1" class="headerlink" title="package名字"></a>package名字</h2><p>保持package的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，尽量和标准库不要冲突。</p><h2 id="import-规范-1"><a href="#import-规范-1" class="headerlink" title="import 规范"></a>import 规范</h2><p>import在多行的情况下，goimports会自动帮你格式化，但是我们这里还是规范一下import的一些规范，如果你在一个文件里面引入了一个package，还是建议采用如下格式：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>如果你的包引入了三种类型的包，标准库包，程序内部包，第三方包，建议采用如下方式进行组织你的包：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br><br>    <span class="hljs-string">&quot;myproject/models&quot;</span><br>    <span class="hljs-string">&quot;myproject/controller&quot;</span><br>    <span class="hljs-string">&quot;myproject/utils&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/astaxie/beego&quot;</span><br>    <span class="hljs-string">&quot;github.com/go-sql-driver/mysql&quot;</span><br>)   <br></code></pre></td></tr></table></figure><p>有顺序的引入包，不同的类型采用空格分离，第一种实标准库，第二是项目包，第三是第三方包。</p><p>在项目中不要使用相对路径引入包：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 这是不好的导入<br>import “../net”<br><br><span class="hljs-regexp">//</span> 这是正确的做法<br>import “github.com<span class="hljs-regexp">/repo/</span>proj<span class="hljs-regexp">/src/</span>net”<br></code></pre></td></tr></table></figure><h2 id="变量申明-1"><a href="#变量申明-1" class="headerlink" title="变量申明"></a>变量申明</h2><p>变量名采用驼峰标准，不要使用<code>_</code>来命名变量名，多个变量申明放在一起</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">var</span> (<br>    Found bool<br>    <span class="hljs-keyword">count</span> <span class="hljs-built_in">int</span><br>)<br></code></pre></td></tr></table></figure><p>在函数外部申明必须使用var,不要采用<code>:=</code>，容易踩到变量的作用域的问题。</p><h2 id="自定义类型的string循环问题-1"><a href="#自定义类型的string循环问题-1" class="headerlink" title="自定义类型的string循环问题"></a>自定义类型的string循环问题</h2><p>如果自定义的类型定义了String方法，那么在打印的时候会产生隐藏的一些bug</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m MyInt)</span></span> String() <span class="hljs-type">string</span> &#123;     <span class="hljs-keyword">return</span> fmt.Sprint(m)   <span class="hljs-comment">//<span class="hljs-doctag">BUG:</span>死循环</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(m MyInt)</span></span> String() <span class="hljs-type">string</span> &#123;     <span class="hljs-keyword">return</span> fmt.Sprint(<span class="hljs-type">int</span>(m))   <span class="hljs-comment">//这是安全的,因为我们内部进行了类型转换</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="避免返回命名的参数-1"><a href="#避免返回命名的参数-1" class="headerlink" title="避免返回命名的参数"></a>避免返回命名的参数</h2><p>如果你的函数很短小，少于10行代码，那么可以使用，不然请直接使用类型，因为如果使用命名变量很<br>容易引起隐藏的bug</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">func <span class="hljs-constructor">Foo(<span class="hljs-params">a</span> <span class="hljs-params">int</span>, <span class="hljs-params">b</span> <span class="hljs-params">int</span>)</span> (<span class="hljs-built_in">string</span>, ok)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>当然如果是有多个相同类型的参数返回，那么命名参数可能更清晰：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *Foo)</span></span> Location() (<span class="hljs-type">float64</span>, <span class="hljs-type">float64</span>, <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p>下面的代码就更清晰了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Location returns f&#x27;s latitude and longitude.</span><br><span class="hljs-comment">// Negative values mean south and west, respectively.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *Foo)</span></span> Location() (lat, long <span class="hljs-type">float64</span>, err <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><h2 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h2><p>错误处理的原则就是不能丢弃任何有返回err的调用，不要采用<code>_</code>丢弃，必须全部处理。接收到错误，要么返回err，要么实在不行就panic，或者使用log记录下来</p><h3 id="error-信息-1"><a href="#error-信息-1" class="headerlink" title="error 信息"></a>error 信息</h3><p>error的信息不要采用大写字母，尽量保持你的错误简短，但是要足够表达你的错误的意思。</p><h2 id="长句子打印或者调用，使用参数进行格式化分行-1"><a href="#长句子打印或者调用，使用参数进行格式化分行-1" class="headerlink" title="长句子打印或者调用，使用参数进行格式化分行"></a>长句子打印或者调用，使用参数进行格式化分行</h2><p>我们在调用<code>fmt.Sprint</code>或者<code>log.Sprint</code>之类的函数时，有时候会遇到很长的句子，我们需要在参数调用处进行多行分割：</p><p>下面是错误的方式：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">log.<span class="hljs-constructor">Printf(“A <span class="hljs-params">long</span> <span class="hljs-params">format</span> <span class="hljs-params">string</span>: %<span class="hljs-params">s</span> %<span class="hljs-params">d</span> %<span class="hljs-params">d</span> %<span class="hljs-params">s</span>”, <span class="hljs-params">myStringParameter</span>, <span class="hljs-params">len</span>(<span class="hljs-params">a</span>)</span>,<br>    expected.Size, defrobnicate(“Anotherlongstringparameter”,<br>        expected.Growth.<span class="hljs-constructor">Nanoseconds()</span> /<span class="hljs-number">1e6</span>))<br></code></pre></td></tr></table></figure><p>应该是如下的方式：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">log</span>.Printf(     “A long <span class="hljs-keyword">format</span> <span class="hljs-keyword">string</span>: %s %d %d %s”,     myStringParameter,<br>    len(a),<br>    expected.Size,<br>    defrobnicate(<br>        “Anotherlongstringparameter”,<br>        expected.Growth.Nanoseconds()/<span class="hljs-number">1e6</span>,     ),<br>）   <br></code></pre></td></tr></table></figure><h2 id="注意闭包的调用-1"><a href="#注意闭包的调用-1" class="headerlink" title="注意闭包的调用"></a>注意闭包的调用</h2><p>在循环中调用函数或者goroutine方法，一定要采用显示的变量调用，不要再闭包函数里面调用循环的参数</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">fori:=<span class="hljs-number">0</span>;<span class="hljs-selector-tag">i</span>&lt;limit;<span class="hljs-selector-tag">i</span>++&#123;<br>    go <span class="hljs-built_in">func</span>()&#123; <span class="hljs-built_in">DoSomething</span>(i) &#125;() <span class="hljs-comment">//错误的做法</span><br>    go <span class="hljs-built_in">func</span>(i int)&#123; <span class="hljs-built_in">DoSomething</span>(i) &#125;(i)<span class="hljs-comment">//正确的做法</span><br>￼&#125;<br></code></pre></td></tr></table></figure><p><a href="http://golang.org/doc/articles/race_detector.html#Race_on_loop_counter">http://golang.org/doc/articles/race_detector.html#Race_on_loop_counter</a></p><h2 id="在逻辑处理中禁用panic-1"><a href="#在逻辑处理中禁用panic-1" class="headerlink" title="在逻辑处理中禁用panic"></a>在逻辑处理中禁用panic</h2><p>在main包中只有当实在不可运行的情况采用panic，例如文件无法打开，数据库无法连接导致程序无法<br>正常运行，但是对于其他的package对外的接口不能有panic，只能在包内采用。</p><p>强烈建议在main包中使用log.Fatal来记录错误，这样就可以由log来结束程序。</p><h2 id="注释规范-1"><a href="#注释规范-1" class="headerlink" title="注释规范"></a>注释规范</h2><p>注释可以帮我们很好的完成文档的工作，写得好的注释可以方便我们以后的维护。详细的如何写注释可以<br>参考：<a href="http://golang.org/doc/effective_go.html#commentary">http://golang.org/doc/effective_go.html#commentary</a></p><h3 id="bug注释-1"><a href="#bug注释-1" class="headerlink" title="bug注释"></a>bug注释</h3><p>针对代码中出现的bug，可以采用如下教程使用特殊的注释，在godocs可以做到注释高亮：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// BUG(astaxie):This divides by zero. </span><br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">i</span> <span class="hljs-attribute">float</span> = <span class="hljs-number">1</span>/<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><a href="http://blog.golang.org/2011/03/godoc%C2%ADdocumenting%C2%ADgo%C2%ADcode.html">http://blog.golang.org/2011/03/godoc­documenting­go­code.html</a></p><h2 id="struct规范-1"><a href="#struct规范-1" class="headerlink" title="struct规范"></a>struct规范</h2><h3 id="struct申明和初始化格式采用多行：-1"><a href="#struct申明和初始化格式采用多行：-1" class="headerlink" title="struct申明和初始化格式采用多行："></a>struct申明和初始化格式采用多行：</h3><p>定义如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">type</span> <span class="hljs-keyword">User</span> <span class="hljs-title">struct</span>&#123;<br>    Username  <span class="hljs-keyword">string</span><br>    Email     <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>初始化如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">u := User&#123;<br>    Username: <span class="hljs-string">&quot;astaxie&quot;</span>,<br>    Email:    <span class="hljs-string">&quot;astaxie@gmail.com&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="recieved是值类型还是指针类型-1"><a href="#recieved是值类型还是指针类型-1" class="headerlink" title="recieved是值类型还是指针类型"></a>recieved是值类型还是指针类型</h3><p>到底是采用值类型还是指针类型主要参考如下原则：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">func</span>(w Win) <span class="hljs-built_in">Tally</span>(playerPlayer)int    <span class="hljs-comment">//w不会有任何改变 </span><br><span class="hljs-built_in">func</span>(w *Win) <span class="hljs-built_in">Tally</span>(playerPlayer)int    <span class="hljs-comment">//w会改变数据</span><br></code></pre></td></tr></table></figure><p>更多的请参考：<a href="https://code.google.com/p/go-wiki/wiki/CodeReviewComments#Receiver_Type">https://code.google.com/p/go-wiki/wiki/CodeReviewComments#Receiver_Type</a></p><h3 id="带mutex的struct必须是指针receivers-1"><a href="#带mutex的struct必须是指针receivers-1" class="headerlink" title="带mutex的struct必须是指针receivers"></a>带mutex的struct必须是指针receivers</h3><p>如果你定义的struct中带有mutex,那么你的receivers必须是指针</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>md常用语法</title>
    <link href="/2022/12/16/md%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/12/16/md%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="MD常用语法"><a href="#MD常用语法" class="headerlink" title="MD常用语法"></a>MD常用语法</h2><p>最近确实需要记住一些常见的md语法，便于后续更加快速方便地撰写博客和技术文档，先整理基础语法如下，后续有需要继续新增。</p><span id="more"></span><h4 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h4><p>使用 <strong>#</strong> 号可表示 1-6 级标题，一级标题对应一个 <strong>#</strong> 号，二级标题对应两个 <strong>#</strong> 号，以此类推。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题<br></code></pre></td></tr></table></figure><h4 id="二、段落样式"><a href="#二、段落样式" class="headerlink" title="二、段落样式"></a>二、段落样式</h4><ol><li>段落换行：用两个以上空格加回车</li><li>字体：</li></ol><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">*斜体文本*</span><br><span class="hljs-emphasis">_斜体文本_</span><br><span class="hljs-strong">**粗体文本**</span><br><span class="hljs-emphasis">__粗体文本__</span><br><span class="hljs-strong">***粗斜体文本**</span>*<br><span class="hljs-emphasis">___粗斜体文本__</span>_<br></code></pre></td></tr></table></figure><ol start="3"><li>分割线：用三个以上的<em>（星号）、-（减号）、_ （下划线）建立分割线，行内不能有其他内容，可在</em>号或-号中间加入空格</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">***</span><br><span class="hljs-comment">* * *</span><br><span class="hljs-comment">*****</span><br>- - -<br>----------<br></code></pre></td></tr></table></figure><ol start="4"><li>删除线：在文字的两端加上两个波浪线<del>即可</del></li></ol><p><del>此内容删除</del></p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml">~~我是要删除的内容~~<br></code></pre></td></tr></table></figure><ol start="5"><li>下划线：通过 HTML 的 <u>标签来实现</u></li></ol><p><u>此内容有下划线</u></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>带下划线文本<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="6"><li>脚注：本体[^我是脚注]</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[^脚注内容]</span><br></code></pre></td></tr></table></figure><h4 id="三、列表"><a href="#三、列表" class="headerlink" title="三、列表"></a>三、列表</h4><ol><li>有序列表：使用 数字加 . 号加空格表示</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 第一项<br><span class="hljs-bullet">2.</span> 第二项<br><span class="hljs-bullet">3.</span> 第三项<br></code></pre></td></tr></table></figure><ol start="2"><li>无序列表：使用星号()、加号(+)或减号(-*) 加空格表示</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 第一项<br><span class="hljs-bullet">*</span> 第二项<br><span class="hljs-bullet">*</span> 第三项<br><br><span class="hljs-bullet">+</span> 第一项<br><span class="hljs-bullet">+</span> 第二项<br><span class="hljs-bullet">+</span> 第三项<br><br><span class="hljs-bullet">-</span> 第一项<br><span class="hljs-bullet">-</span> 第二项<br><span class="hljs-bullet">-</span> 第三项<br></code></pre></td></tr></table></figure><ol start="2"><li>嵌套列表：需在子列表中的选项前面添加四个空格</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 第一项：<br><span class="hljs-bullet">    -</span> 第一项嵌套的第一个元素<br><span class="hljs-bullet">    -</span> 第一项嵌套的第二个元素<br><span class="hljs-bullet">2.</span> 第二项：<br><span class="hljs-bullet">    -</span> 第二项嵌套的第一个元素<br><span class="hljs-bullet">    -</span> 第二项嵌套的第二个元素<br></code></pre></td></tr></table></figure><h4 id="四、区块"><a href="#四、区块" class="headerlink" title="四、区块"></a>四、区块</h4><ol><li>区块引用：在段落开头使用 &gt; 符号加空格</li></ol><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">区块引用</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">菜鸟教程</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">学的不仅是技术更是梦想</span><br></code></pre></td></tr></table></figure><ol start="2"><li>区块嵌套：一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推</li></ol><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">最外层</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">&gt; 第一层嵌套</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">&gt; &gt; 第二层嵌套</span><br></code></pre></td></tr></table></figure><ol start="3"><li>区块中使用列表</li></ol><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">区块中使用列表</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">1.</span> 第一项</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">2.</span> 第二项</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">+ 第一项</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">+ 第二项</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">+ 第三项</span><br></code></pre></td></tr></table></figure><ol start="4"><li>列表中使用区块</li></ol><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>第一项<br><span class="hljs-code">    &gt; 菜鸟教程</span><br><span class="hljs-code">    &gt; 学的不仅是技术更是梦想</span><br><span class="hljs-bullet">* </span>第二项<br></code></pre></td></tr></table></figure><h4 id="五、代码块"><a href="#五、代码块" class="headerlink" title="五、代码块"></a>五、代码块</h4><ol><li>段落中的函数：函数前后使用反引号 我是函数<code>main</code>包起来</li></ol><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">`main()`函数<br></code></pre></td></tr></table></figure><ol start="2"><li>代码区块：用 4 个空格、一个制表符（Tab 键）或3个反引号表示</li></ol><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">```我是代码块<span class="hljs-number">1</span>```<br>```我是代码块<span class="hljs-number">2</span>```<br>```java 我是代码块<span class="hljs-number">3</span>，并指定了语言为Java ```<br></code></pre></td></tr></table></figure><h4 id="六、链接"><a href="#六、链接" class="headerlink" title="六、链接"></a>六、链接</h4><ol><li>普通链接：[链接名称] (链接地址) 或 &lt;链接地址&gt;</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less">这是一个链接 <span class="hljs-selector-attr">[菜鸟教程]</span>(<span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.runoob.com)</span><br></code></pre></td></tr></table></figure><ol start="2"><li>高级链接：通过变量设置一个链接，变量在文档末尾赋值</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less">这个链接用 <span class="hljs-selector-tag">a</span> 作为网址变量 <span class="hljs-selector-attr">[Google]</span><span class="hljs-selector-attr">[a]</span><br>这个链接用 <span class="hljs-selector-tag">b</span> 作为网址变量 <span class="hljs-selector-attr">[Runoob]</span><span class="hljs-selector-attr">[b]</span><br>然后在文档的结尾为变量赋值（网址）<br><br>  <span class="hljs-selector-attr">[a]</span>: <span class="hljs-selector-tag">http</span>:<span class="hljs-comment">//www.google.com/</span><br>  <span class="hljs-selector-attr">[b]</span>: <span class="hljs-selector-tag">http</span>:<span class="hljs-comment">//www.runoob.com/</span><br></code></pre></td></tr></table></figure><h4 id="七、图片"><a href="#七、图片" class="headerlink" title="七、图片"></a>七、图片</h4><ol><li>语法格式：<code>![alt 属性文本](图片地址)或![alt 属性文本](图片地址 &quot;可选标题&quot;)</code></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">![RUNOOB 图标](http:<span class="hljs-regexp">//</span>static.runoob.com<span class="hljs-regexp">/images/</span>runoob-logo.png)<br>![RUNOOB 图标](http:<span class="hljs-regexp">//</span>static.runoob.com<span class="hljs-regexp">/images/</span>runoob-logo.png <span class="hljs-string">&quot;RUNOOB&quot;</span>)<br></code></pre></td></tr></table></figure><ol start="2"><li>图片地址使用变量</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less">这个链接用 <span class="hljs-selector-tag">a</span> 作为网址变量 <span class="hljs-selector-attr">[RUNOOB]</span><span class="hljs-selector-attr">[a]</span>.<br>然后在文档的结尾为变量赋值（网址）<br><span class="hljs-selector-attr">[a]</span>: <span class="hljs-selector-tag">http</span>:<span class="hljs-comment">//static.runoob.com/images/runoob-logo.png</span><br></code></pre></td></tr></table></figure><ol start="3"><li>使用本地图片</li></ol><h4 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h4><ol><li>语法：使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行</li></ol><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">  表头   </span>|<span class="hljs-string"> 表头  </span>|<br>|<span class="hljs-string">  ----  </span>|<span class="hljs-string"> ----  </span>|<br>|<span class="hljs-string"> 单元格  </span>|<span class="hljs-string"> 单元格 </span>|<br>|<span class="hljs-string"> 单元格  </span>|<span class="hljs-string"> 单元格 </span>|<br></code></pre></td></tr></table></figure><ol start="2"><li>表格中对齐方式</li></ol><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> 左对齐 </span>|<span class="hljs-string"> 右对齐 </span>|<span class="hljs-string"> 居中对齐 </span>|<br>|<span class="hljs-string"> :-----</span>|<span class="hljs-string"> ----: </span>|<span class="hljs-string"> :----: </span>|<br>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<br>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<br></code></pre></td></tr></table></figure><h4 id="九、高级技巧"><a href="#九、高级技巧" class="headerlink" title="九、高级技巧"></a>九、高级技巧</h4><ol><li>支持的HTML元素：目前支持的 HTML 元素有：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">使用 &lt;<span class="hljs-selector-tag">kbd</span>&gt;Ctrl&lt;/<span class="hljs-selector-tag">kbd</span>&gt;+&lt;<span class="hljs-selector-tag">kbd</span>&gt;Alt&lt;/<span class="hljs-selector-tag">kbd</span>&gt;+&lt;<span class="hljs-selector-tag">kbd</span>&gt;<span class="hljs-selector-tag">Del</span>&lt;/<span class="hljs-selector-tag">kbd</span>&gt; 重启电脑<br></code></pre></td></tr></table></figure><p>使用Ctrl+Alt+Del重启电脑</p><ol start="2"><li>转义： 使用反斜杠转义特殊字符</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">\   反斜线<br>`   反引号<br><span class="hljs-bullet">*</span>   星号<br>_   下划线<br>&#123;&#125;  花括号<br>[]  方括号<br>()  小括号<br><span class="hljs-section">#   井字号</span><br><span class="hljs-bullet">+</span>   加号<br><span class="hljs-bullet">-</span>   减号<br>.   英文句点<br>!   感叹号<br></code></pre></td></tr></table></figure><ol start="3"><li>公式：很少用，暂不研究</li></ol>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件安装和使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="/2022/12/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/12/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h2><p>❀❀❀我爱我宝！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
